## Общие сведения 

Thread.start() - только при вызове start() будет создаваться новый поток
Runnable.run() - выполнит код в том же (основном) потоке

Что бы выполнить код в новом потоке:
```
Thread t = new MyThread();
t.start();
```

Есть обычные и фоновые потоки. Программа не завершится пока есть хотя бы один обычный поток. 
В обоих потоках можно создавать потоки любых типов

Ждем завершения потока и только после завершения потока будет выполнена остальная часть кода
```
thread.join();
```

С каждым объектом Thread ассоциируется один поток в операционной системе, и метод start можно вызвать только один раз
Если вызовем второй раз start(), то получим исключение

interrupt() - прерывание выполнения потока (по факту просто меняется флаг на true и в коде нужно добавлять проверки на этот флаг).
Но если код не обрабатывает прерывания, бесполезно использовать метод interrupt

В JVM есть две большие области:
1. куча (heap) - там находятся объекты и примитивы, доступные всем потокам
2. стеки потоков (stack memory). У каждого потока есть свой стек, в котором хранятся локальные примитивы потока и ссылки на объекты из кучи

## Executor
Основная задача: организация пулов потоков и управления очередью. Executor сам позаботится о создании и завершении потоков
Основные виды которые чаще используются на практике:
1. Executors.newSingleThreadExecutor() - с одним потоком в пуле
2. Executors.newFixedThreadPool(int nThreads) - с числом потоков, равным nThreads
3. Executors.newCachedThreadPool() - число потоков в пуле - динамическое. При необходимости потоки добавляются в пул, но если поток простаивает минуту, он удаляется

## Volatile
Изменение volatile переменной сразу видны всем потокам. Это одно из решений проблемы видимости
```
private volatile int value;

public void setValue(int value) {
    this.value = value;
}

public int getValue() {
    return value;
}
```
Метод getValue() будет всегда возвращать актуальное значение переменной value. Даже если другой поток обновил его всего 0,000001 секунды назад.

## Synchronized
Ключевое слово synchronized гарантирует, что только один поток может зайти в обозначенный участок кода. Синтаксис:

```
private Object lock = new Object();  // объявляем объект синхронизации

public void smth() {
    synchronized (lock) {           // синхронизируемся по объекту lock        
        // критическая секция, сюда может зайти только один поток
    }           
}
```
Блок кода, в который допускается один поток, называется критической секцией. Она ограничивается фигурными скобками.

Объект синхронизации указывается в скобках после слова synchronized. Он помогает "охранять" критическую секцию.

Что происходит под капотом
С каждым объектом ассоциирована специфичная структура внутри JVM - монитор. Когда поток входит в synchronized секцию, у монитора прописывается владелец. Это называется захватом монитора. Захват происходит на уровне JVM и недоступен программисту напрямую.

Только один поток может владеть монитором. Соответственно только один поток может находится в synchronized секции.

3 способа использовать synchronized
1. Обозначить блок кода
2. Добавить synchronized в сигнатуру метода
3. Добавить synchronized в сигнатуру статического метода


## Типы синхронизации
1. **Синхронизированные методы и блоки**:
    - Вы можете объявить метод как `synchronized`, чтобы гарантировать, что только один поток может его выполнять в любое время.
    - Также можно использовать синхронизированные блоки внутри методов, чтобы повысить эффективность, синхронизируя только критические участки кода.

```java
   public synchronized void synchronizedMethod() {
       // код
   }

   public void someMethod() {
       synchronized (this) {
           // критическая секция
       }
   }
```

2. **Объектный монитор (monitor)**:
    - Каждый объект в Java имеет монитор, который используется для синхронизации. Поскольку только один поток может обладать монитором в данный момент времени, это позволяет защищать критические секции.

3. **Класс `ReentrantLock`**:
    - Это более гибкий способ синхронизации, позволяющий использовать блокировки, которые можно захватывать и разблокировать в любом порядке.

```java
   Lock lock = new ReentrantLock();

   lock.lock();
   try {
       // критическая секция
   } finally {
       lock.unlock();
   }
```

4. **Классы из пакета `java.util.concurrent`**:
    - `CountDownLatch`, `CyclicBarrier`, `Semaphore`, `Exchanger`, `BlockingQueue` и другие классы предоставляют удобные механизмы для синхронизации и работы с потоками.

5. **Статические и экземплярные блоки `synchronized`**:
    - Вы можете синхронизировать статические методы или блоки, которые работают с классом, а не с конкретным экземпляром.

```java
   public static synchronized void synchronizedStaticMethod() {
       // код
   }
```

6. **Пул потоков (`ExecutorService`)**:
    - Хотя это не метод синхронизации в традиционном смысле, использование пула потоков позволяет управлять многопоточностью и снижать риски состояния гонки.

7. **Не блокирующие структуры данных**:
    - Java предоставляет не блокирующие коллекции, такие как `ConcurrentHashMap`, `CopyOnWriteArrayList`, которые позволяют безопасно работать с данными из нескольких потоков без явной синхронизации.

8. **Атомарные типы**:
    - Пакет `java.util.concurrent.atomic` содержит класс атомарных переменных, таких как `AtomicInteger`, `AtomicBoolean`, которые обеспечивают безопасное обновление значений из нескольких потоков.