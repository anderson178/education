## Общие сведения 

Thread.start() - только при вызове start() будет создаваться новый поток
Runnable.run() - выполнит код в том же (основном) потоке

Что бы выполнить код в новом потоке:
```
Thread t = new MyThread();
t.start();
```

Есть обычные и фоновые потоки. Программа не завершится пока есть хотя бы один обычный поток. 
В обоих потоках можно создавать потоки любых типов

Ждем завершения потока и только после завершения потока будет выполнена остальная часть кода
```
thread.join();
```

С каждым объектом Thread ассоциируется один поток в операционной системе, и метод start можно вызвать только один раз
Если вызовем второй раз start(), то получим исключение

interrupt() - прерывание выполнения потока (по факту просто меняется флаг на true и в коде нужно добавлять проверки на этот флаг).
Но если код не обрабатывает прерывания, бесполезно использовать метод interrupt

В JVM есть две большие области:
1. куча (heap) - там находятся объекты и примитивы, доступные всем потокам
2. стеки потоков (stack memory). У каждого потока есть свой стек, в котором хранятся локальные примитивы потока и ссылки на объекты из кучи

## Executor
Основная задача: организация пулов потоков и управления очередью. Executor сам позаботится о создании и завершении потоков
Основные виды которые чаще используются на практике:
1. Executors.newSingleThreadExecutor() - с одним потоком в пуле
2. Executors.newFixedThreadPool(int nThreads) - с числом потоков, равным nThreads
3. Executors.newCachedThreadPool() - число потоков в пуле - динамическое. При необходимости потоки добавляются в пул, но если поток простаивает минуту, он удаляется

## Volatile
Изменение volatile переменной сразу видны всем потокам. Это одно из решений проблемы видимости
```
private volatile int value;

public void setValue(int value) {
    this.value = value;
}

public int getValue() {
    return value;
}
```
Метод getValue() будет всегда возвращать актуальное значение переменной value. Даже если другой поток обновил его всего 0,000001 секунды назад.

## Synchronized
Ключевое слово synchronized гарантирует, что только один поток может зайти в обозначенный участок кода. Синтаксис:

```
private Object lock = new Object();  // объявляем объект синхронизации

public void smth() {
    synchronized (lock) {           // синхронизируемся по объекту lock        
        // критическая секция, сюда может зайти только один поток
    }           
}
```
Блок кода, в который допускается один поток, называется критической секцией. Она ограничивается фигурными скобками.

Объект синхронизации указывается в скобках после слова synchronized. Он помогает "охранять" критическую секцию.

Что происходит под капотом
С каждым объектом ассоциирована специфичная структура внутри JVM - монитор. Когда поток входит в synchronized секцию, у монитора прописывается владелец. Это называется захватом монитора. Захват происходит на уровне JVM и недоступен программисту напрямую.

Только один поток может владеть монитором. Соответственно только один поток может находится в synchronized секции.

3 способа использовать synchronized
1. Обозначить блок кода
2. Добавить synchronized в сигнатуру метода
3. Добавить synchronized в сигнатуру статического метода