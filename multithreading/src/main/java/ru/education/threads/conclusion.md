## Общие сведения 

Thread.start() - только при вызове start() будет создаваться новый поток
Runnable.run() - выполнит код в том же (основном) потоке

Что бы выполнить код в новом потоке:
```
Thread t = new MyThread();
t.start();
```

Есть обычные и фоновые потоки. Программа не завершится пока есть хотя бы один обычный поток. 
В обоих потоках можно создавать потоки любых типов

Ждем завершения потока и только после завершения потока будет выполнена остальная часть кода
```
thread.join();
```

С каждым объектом Thread ассоциируется один поток в операционной системе, и метод start можно вызвать только один раз
Если вызовем второй раз start(), то получим исключение

interrupt() - прерывание выполнения потока (по факту просто меняется флаг на true и в коде нужно добавлять проверки на этот флаг).
Но если код не обрабатывает прерывания, бесполезно использовать метод interrupt

В JVM есть две большие области:
1. куча (heap) - там находятся объекты и примитивы, доступные всем потокам
2. стеки потоков (stack memory). У каждого потока есть свой стек, в котором хранятся локальные примитивы потока и ссылки на объекты из кучи

## Executor
Основная задача: организация пулов потоков и управления очередью. Executor сам позаботится о создании и завершении потоков
Основные виды которые чаще используются на практике:
1. Executors.newSingleThreadExecutor() - с одним потоком в пуле
2. Executors.newFixedThreadPool(int nThreads) - с числом потоков, равным nThreads
3. Executors.newCachedThreadPool() - число потоков в пуле - динамическое. При необходимости потоки добавляются в пул, но если поток простаивает минуту, он удаляется